> 已经有了ida， 还需要radare2吗?

● 取决于你的使用场景。简单回答：大多数情况下不需要，但radare2在某些场景有独特价值。

  IDA vs radare2 对比

  | 方面     | IDA               | radare2                 |
  |----------|-------------------|-------------------------|
  | GUI      | 优秀              | 有Cutter，但不如IDA     |
  | 反编译   | Hex-Rays 行业顶级 | Ghidra插件/有限支持     |
  | 自动分析 | 更智能            | 需要更多手动操作        |
  | 脚本化   | IDAPython         | r2pipe，更适合CLI自动化 |
  | 价格     | 昂贵              | 免费开源                |

  可能需要radare2的场景

  1. 自动化/批处理 - r2的命令行设计更适合脚本批量分析
  2. 嵌入式/IoT - 支持更多冷门架构
  3. 轻量快速查看 - 不想启动IDA时快速看一眼二进制
  4. CTF比赛 - 某些题目用r2更顺手
  5. 服务器端部署 - 无GUI环境下的分析

  建议

  - 如果IDA已经满足你的日常需求，不用装radare2
  - 如果你经常做自动化分析或需要CLI工具，可以考虑作为补充
  - 如果预算有限没有IDA，radare2 + Ghidra是免费替代方案

  你主要做什么类型的逆向分析？

> 自动化/批处理 r2 强在哪里？

● r2 的设计哲学就是 "一切皆命令"，天然适合脚本化。

  核心优势

  1. 命令行原生设计

  # 一行命令提取所有函数名
  r2 -q -c "aaa; afl" target.exe

  # 批量分析目录下所有二进制
  for f in *.exe; do r2 -q -c "aaa; iI" "$f" >> report.txt; done

  IDA 虽然有 idat（headless模式），但配置复杂，启动慢。

  2. r2pipe - 多语言绑定

  import r2pipe

  r2 = r2pipe.open("malware.exe")
  r2.cmd("aaa")  # 分析
  funcs = r2.cmdj("aflj")  # 返回JSON

  for f in funcs:
      print(f["name"], hex(f["offset"]))

  支持 Python、JS、Go、Rust 等，直接嵌入你的工具链。

  3. JSON 输出

  # 几乎所有命令加 j 后缀输出JSON
  r2 -q -c "aaa; aflj" target.exe | jq '.[] | .name'

  便于管道处理和数据解析。

  4. 无GUI依赖

  - 服务器/Docker环境直接运行
  - 资源占用小，启动秒级
  - 适合CI/CD集成（如自动化恶意软件分析管道）

  典型应用场景

  | 场景           | r2 做法                 |
  |----------------|-------------------------|
  | 批量提取字符串 | r2 -q -c "izj" *.bin    |
  | 对比两个二进制 | radiff2 a.exe b.exe     |
  | 自动化漏洞扫描 | r2pipe + 自定义规则脚本 |
  | 恶意软件分类   | 提取特征 → 机器学习     |

  IDA 的局限

  - headless 模式需要额外许可证（IDA Teams/Batch）
  - IDAPython 脚本依赖IDA环境
  - 启动一个实例就要几秒到十几秒

  ---
  如果你只是偶尔写个脚本分析单个文件，IDAPython 够用。但如果要 批量处理几百上千个样本，r2 效率高很多。

> 我使用git + cmake开发， 我想添加一个第三方应该怎么做，拿capstone举例

● 有几种主流方式，推荐程度从高到低：

  方式1：FetchContent（推荐）

  CMake 3.11+，最简洁，无需额外操作：

  include(FetchContent)

  FetchContent_Declare(
      capstone
      GIT_REPOSITORY https://github.com/capstone-engine/capstone.git
      GIT_TAG        5.0.1  # 指定版本
  )

  FetchContent_MakeAvailable(capstone)

  # 使用
  target_link_libraries(your_target PRIVATE capstone)

  优点：一键构建，无需手动管理
  缺点：每次clean build会重新下载

  ---
  方式2：Git Submodule + add_subdirectory

  # 添加 submodule
  git submodule add https://github.com/capstone-engine/capstone.git third_party/capstone
  git submodule update --init --recursive

  # CMakeLists.txt
  add_subdirectory(third_party/capstone)
  target_link_libraries(your_target PRIVATE capstone)

  优点：版本锁定在仓库里，clone后 git submodule update --init 即可
  缺点：需要手动管理submodule

  ---
  方式3：find_package（系统安装）

  先安装 capstone：
  # vcpkg
  vcpkg install capstone

  # 或系统包管理器
  sudo apt install libcapstone-dev  # Ubuntu

  find_package(capstone REQUIRED)
  target_link_libraries(your_target PRIVATE capstone::capstone)

  优点：编译快，不重复构建
  缺点：依赖外部环境，跨平台麻烦

  ---
  推荐项目结构

  your_project/
  ├── CMakeLists.txt
  ├── src/
  ├── include/
  └── third_party/       # submodule 方式放这里
      └── capstone/

  ---
  我的建议

  | 场景                      | 推荐方式      |
  |---------------------------|---------------|
  | 小项目/快速原型           | FetchContent  |
  | 正式项目/团队协作         | Git Submodule |
  | 已有包管理器(vcpkg/conan) | find_package  |

  你项目目前用的是哪种依赖管理方式？还是第一次添加第三方库？

> 我在纠结 FetchContent 和 Git Submodule + add_subdirectory， 我应该怎么选择

● 核心区别就一点：依赖由谁管理

  |          | FetchContent    | Git Submodule        |
  |----------|-----------------|----------------------|
  | 依赖存储 | CMake构建时下载 | Git仓库里            |
  | 版本控制 | CMakeLists.txt  | .gitmodules + commit |
  | 离线构建 | ❌ 需要网络     | ✅ clone后即可       |
  | 仓库体积 | 小              | 大（含依赖）         |
  | CI缓存   | 需额外配置      | 天然支持             |

  ---
  选 Git Submodule 的情况

  - 需要离线构建（内网环境、出差）
  - CI/CD 频繁构建，不想每次重新下载
  - 依赖库你可能需要修改源码
  - 团队成员网络环境不稳定

  选 FetchContent 的情况

  - 个人项目，不在乎构建时下载
  - 依赖较多，不想让仓库太臃肿
  - 依赖库更新频繁，想方便切换版本
  - 纯净主义，仓库只放自己的代码

  ---
  实际体验差异

  # Git Submodule
  git clone --recursive your_repo  # 一次搞定
  cmake -B build && cmake --build build  # 立即构建

  # FetchContent
  git clone your_repo
  cmake -B build  # ← 这里开始下载依赖，可能卡住

  ---
  我的建议

  默认选 Git Submodule，因为：

  1. 构建可预测，不依赖网络
  2. git log 能看到依赖版本变更历史
  3. 大多数开源项目都这么做

  除非你明确讨厌 submodule 的额外命令（git submodule update --init）。

  ---
  要不要我给一个结合两者优点的混合方案？（本地用submodule，fallback到FetchContent）

> 使用 Git Submodule + add_subdirectory后 如果修改了capstone 源码会怎么样？

● Git 会检测到变更，但分两层管理：

  修改后的状态

  # 假设你改了 capstone 的某个文件
  cd third_party/capstone
  echo "// hack" >> cs.c

  # 回到主仓库查看状态
  cd ../..
  git status

  输出：
  Changes not staged for commit:
      modified:   third_party/capstone (modified content)

  注意是 (modified content)，不是具体文件名。主仓库只知道 submodule 有变化，不知道改了什么。

  ---
  你有两个选择

  选项1：提交修改（Fork 模式）

  # 1. 进入 submodule 提交
  cd third_party/capstone
  git add -A
  git commit -m "my custom patch"

  # 2. 回主仓库，更新 submodule 引用
  cd ../..
  git add third_party/capstone
  git commit -m "update capstone to patched version"

  问题：你的 commit 在本地，push 到哪？

  → 需要 fork capstone，把 submodule 指向你的 fork：
  cd third_party/capstone
  git remote set-url origin git@github.com:YOU/capstone.git
  git push

  选项2：放弃修改

  cd third_party/capstone
  git checkout .  # 丢弃所有修改

  ---
  实际项目中的做法

  | 情况           | 推荐做法                          |
  |----------------|-----------------------------------|
  | 临时调试/实验  | 改完测完就 git checkout . 还原    |
  | 长期需要的补丁 | Fork 并维护自己的分支             |
  | 通用性修复     | 给上游提 PR，合并后更新 submodule |

  ---
  一个坑

  如果团队成员 clone 你的仓库：
  git clone --recursive your_repo

  他们拉到的是 你提交时指向的那个 commit，包含你的修改（前提是你 push 到了可访问的 remote）。

  如果你只本地 commit 没 push，别人拉取会报错。

> cpp 类名是BinaryModule 风格， 结构体风格应该是什么样的，

● C++ 中 struct 和 class 几乎等价，所以主流做法是用同样的 PascalCase：

  class  BinaryModule { ... };   // 类
  struct BinaryModuleInfo { ... };  // 结构体，同风格

  ---
  常见流派

  | 风格              | 类           | 结构体                       | 代表项目              |
  |-------------------|--------------|------------------------------|-----------------------|
  | 统一 PascalCase   | BinaryModule | ModuleInfo                   | Google, LLVM, Qt      |
  | C 风格 snake_case | BinaryModule | module_info 或 module_info_t | Linux kernel 风格混用 |
  | 后缀区分          | BinaryModule | BinaryModuleData             | 自定义                |

  ---
  实践建议

  用语义而非关键字区分：

  // 类：有行为、有不变量、需要封装
  class BinaryModule {
  public:
      void load();
  private:
      Handle handle_;
  };

  // 结构体：纯数据、公开字段、POD-like
  struct ModuleInfo {
      std::string name;
      uint64_t base_addr;
      size_t size;
  };

  命名风格一致，都用 PascalCase，靠用途区分，不靠大小写区分。

  ---
  如果你想视觉区分

  有些人喜欢给纯数据结构体加后缀：

  struct ModuleInfo { ... };    // 数据
  struct ModuleConfig { ... };  // 配置
  struct ModuleResult { ... };  // 返回结果

  后缀本身暗示了"这是数据容器"。

  ---
  你们项目有现成的代码规范吗？还是从零开始定？

> 从零开始定， 拿枚举类型呢？

● 枚举要定两个东西：类型名 和 枚举值

  推荐风格

  // 类型名：PascalCase（和 class/struct 统一）
  // 枚举值：kPascalCase 或 PascalCase
  enum class ModuleType {
      Executable,
      SharedLibrary,
      StaticLibrary,
  };

  ---
  枚举值常见流派

  | 风格        | 示例        | 代表                     |
  |-------------|-------------|--------------------------|
  | PascalCase  | Executable  | LLVM, Qt                 |
  | kPascalCase | kExecutable | Google C++ Style         |
  | ALL_CAPS    | EXECUTABLE  | C 传统，Windows API      |
  | snake_case  | executable  | STL (std::launch::async) |

  ---
  我的建议

  // ✅ 用 enum class（强类型，有作用域）
  enum class ModuleType {
      Executable,
      SharedLibrary,
      Unknown,
  };

  // 使用时
  ModuleType type = ModuleType::Executable;

  不推荐传统 enum：
  // ❌ 污染命名空间，容易冲突
  enum ModuleType {
      Executable,      // 全局可见
      SharedLibrary,
  };

  ---
  完整规范建议

  | 类型      | 风格                    | 示例                         |
  |-----------|-------------------------|------------------------------|
  | 类/结构体 | PascalCase              | BinaryModule                 |
  | 枚举类型  | PascalCase              | ModuleType                   |
  | 枚举值    | PascalCase              | ModuleType::Executable       |
  | 函数      | PascalCase 或 camelCase | LoadModule() 或 loadModule() |
  | 变量      | snake_case              | module_info                  |
  | 成员变量  | snake_case_             | module_info_                 |
  | 常量      | kPascalCase             | kMaxSize                     |
  | 宏        | ALL_CAPS                | DEBUG_LOG                    |

  这基本是 Google/LLVM 风格的混合，业界接受度高。

  要定函数和变量的风格吗？

> 结构体的字段呢？

● 结构体字段和类成员变量要区分对待：

  // 类：私有成员，带下划线后缀
  class BinaryModule {
  private:
      std::string name_;
      uint64_t base_addr_;
  };

  // 结构体：公开字段，不带后缀
  struct ModuleInfo {
      std::string name;
      uint64_t base_addr;
      size_t size;
  };

  ---
  原因

  |        | 类成员                | 结构体字段                |
  |--------|-----------------------|---------------------------|
  | 访问性 | 通常 private          | 通常 public               |
  | 后缀 _ | ✅ 区分成员和局部变量 | ❌ 不需要，本来就直接访问 |
  | 用途   | 有封装、有不变量      | 纯数据容器                |

  ---
  使用体验

  ModuleInfo info;
  info.name = "test";       // ✅ 干净
  info.name_ = "test";      // ❌ 别扭

  module.name_ = "x";       // 类内部用，合理
  module.getName();         // 外部用接口

  ---
  完整规范（更新）

  | 类型          | 风格        | 示例                     |
  |---------------|-------------|--------------------------|
  | 类名/结构体名 | PascalCase  | BinaryModule, ModuleInfo |
  | 枚举类型      | PascalCase  | ModuleType               |
  | 枚举值        | PascalCase  | ModuleType::Executable   |
  | 类私有成员    | snake_case_ | base_addr_               |
  | 结构体字段    | snake_case  | base_addr                |
  | 局部变量      | snake_case  | module_count             |
  | 函数/方法     | PascalCase  | LoadModule()             |
  | 常量          | kPascalCase | kMaxSize                 |

  这样一眼就能区分"这是类的封装成员"还是"纯数据字段"。

> 二进制分析中，应该把正汇编器和反汇编器封装成一个Archtiecture类吗？

● 这是个经典的架构设计问题。看看业界怎么做的：

  业界做法

  | 项目              | 设计                                 |
  |-------------------|--------------------------------------|
  | Capstone/Keystone | 分离，两个独立库                     |
  | LLVM              | 分离，MCDisassembler / MCCodeEmitter |
  | Binary Ninja      | 统一，Architecture 类包含两者        |
  | Ghidra            | 统一，Language 包含指令语义          |

  ---
  两种设计

  方案1：统一到 Architecture

  class Architecture {
  public:
      virtual std::string name() const = 0;
      virtual size_t pointerSize() const = 0;

      // 反汇编
      virtual DisassembleResult disassemble(const uint8_t* code, size_t size, uint64_t addr) = 0;

      // 汇编
      virtual AssembleResult assemble(const std::string& asm_text, uint64_t addr) = 0;
  };

  优点：API 简洁，用户拿到一个对象就能干所有事
  缺点：类职责较多，可能变臃肿

  方案2：分离 + 工厂

  class Architecture {
  public:
      virtual std::string name() const = 0;
      virtual size_t pointerSize() const = 0;

      virtual std::unique_ptr<Disassembler> createDisassembler() = 0;
      virtual std::unique_ptr<Assembler> createAssembler() = 0;
  };

  class Disassembler {
  public:
      virtual DisassembleResult disassemble(const uint8_t* code, size_t size, uint64_t addr) = 0;
  };

  优点：职责分离，按需创建
  缺点：API 多一层

  ---
  我的建议

  用方案2（分离 + 工厂），理由：

  1. 按需加载 - 反汇编用 Capstone，汇编用 Keystone，可以独立替换
  2. 不是所有架构都支持汇编 - 有些你只有反汇编器
  3. 状态隔离 - Disassembler 可能有缓存、模式设置，独立更清晰
  4. 测试更容易 - 可以单独 mock

  auto arch = ArchitectureRegistry::get("x86_64");
  auto disasm = arch->createDisassembler();

  // 只用反汇编，不关心汇编器
  auto result = disasm->disassemble(code, size, addr);

  ---
  你的场景需要汇编功能吗？还是主要做反汇编分析？

> 先当只做反汇编分析，但是后面可以会需要修改只能进行正汇编

● 那就先做减法，预留扩展点：

  现阶段设计

  class Architecture {
  public:
      virtual ~Architecture() = default;

      virtual std::string name() const = 0;
      virtual size_t pointerSize() const = 0;
      virtual Endian endian() const = 0;

      virtual std::unique_ptr<Disassembler> createDisassembler() = 0;

      // 未来加这个，现在不实现
      // virtual std::unique_ptr<Assembler> createAssembler() = 0;
  };

  class Disassembler {
  public:
      virtual ~Disassembler() = default;
      virtual DisassembleResult disassemble(std::span<const uint8_t> code, uint64_t addr) = 0;
  };

  现在就这些，干净。

  ---
  未来加汇编时

  两种方式，无需改现有代码：

  方式1：直接加方法（推荐）

  class Architecture {
  public:
      // ... 现有接口不变

      virtual std::unique_ptr<Assembler> createAssembler() {
          return nullptr;  // 默认不支持
      }

      bool supportsAssemble() const {
          return createAssembler() != nullptr;
      }
  };

  方式2：运行时能力查询

  class Architecture {
  public:
      enum class Capability {
          Disassemble,
          Assemble,
          Lift,  // 未来可能还有 IR lifting
      };

      virtual bool supports(Capability cap) const = 0;
  };

  ---
  建议

  现在用方式1 的简化版，连 createAssembler 都不用写：

  // architecture.h - 现在
  class Architecture {
  public:
      virtual std::unique_ptr<Disassembler> createDisassembler() = 0;
  };

  // 半年后需要汇编了，直接加
  class Architecture {
  public:
      virtual std::unique_ptr<Disassembler> createDisassembler() = 0;
      virtual std::unique_ptr<Assembler> createAssembler() = 0;  // 新增
  };

  纯虚函数加上去，编译器会告诉你哪些子类需要实现。

  ---
  YAGNI 原则：现在不需要，就不写。接口加方法是向后兼容的，不用担心。

  要我给一个 Disassembler 封装 Capstone 的示例吗？

> 给一个 Disassembler 封装 Capstone 的示例

● // ==================== disassembler.h ====================
  #pragma once
  #include <cstdint>
  #include <span>
  #include <string>
  #include <vector>

  struct Instruction {
      uint64_t address;
      std::vector<uint8_t> bytes;
      std::string mnemonic;
      std::string operands;

      std::string text() const {
          return mnemonic + " " + operands;
      }
  };

  struct DisassembleResult {
      std::vector<Instruction> instructions;
      size_t bytes_consumed;
  };

  class Disassembler {
  public:
      virtual ~Disassembler() = default;
      virtual DisassembleResult disassemble(std::span<const uint8_t> code, uint64_t addr) = 0;
  };

  // ==================== capstone_disasm.h ====================
  #pragma once
  #include "disassembler.h"
  #include <capstone/capstone.h>
  #include <stdexcept>

  class CapstoneDisassembler : public Disassembler {
  public:
      CapstoneDisassembler(cs_arch arch, cs_mode mode) {
          if (cs_open(arch, mode, &handle_) != CS_ERR_OK) {
              throw std::runtime_error("Failed to initialize Capstone");
          }
          cs_option(handle_, CS_OPT_DETAIL, CS_OPT_ON);
      }

      ~CapstoneDisassembler() override {
          cs_close(&handle_);
      }

      // 禁止拷贝
      CapstoneDisassembler(const CapstoneDisassembler&) = delete;
      CapstoneDisassembler& operator=(const CapstoneDisassembler&) = delete;

      DisassembleResult disassemble(std::span<const uint8_t> code, uint64_t addr) override {
          DisassembleResult result{};
          cs_insn* insn = nullptr;

          size_t count = cs_disasm(handle_, code.data(), code.size(), addr, 0, &insn);

          if (count > 0) {
              result.instructions.reserve(count);
              for (size_t i = 0; i < count; i++) {
                  result.instructions.push_back({
                      .address = insn[i].address,
                      .bytes = {insn[i].bytes, insn[i].bytes + insn[i].size},
                      .mnemonic = insn[i].mnemonic,
                      .operands = insn[i].op_str,
                  });
                  result.bytes_consumed += insn[i].size;
              }
              cs_free(insn, count);
          }

          return result;
      }

  private:
      csh handle_{};
  };

  // ==================== architecture.h ====================
  #pragma once
  #include "disassembler.h"
  #include <memory>
  #include <string>

  enum class Endian { Little, Big };

  class Architecture {
  public:
      virtual ~Architecture() = default;
      virtual std::string name() const = 0;
      virtual size_t pointerSize() const = 0;
      virtual Endian endian() const = 0;
      virtual std::unique_ptr<Disassembler> createDisassembler() = 0;
  };

  // ==================== arch_x86.h ====================
  #pragma once
  #include "architecture.h"
  #include "capstone_disasm.h"

  class ArchX86 : public Architecture {
  public:
      std::string name() const override { return "x86"; }
      size_t pointerSize() const override { return 4; }
      Endian endian() const override { return Endian::Little; }

      std::unique_ptr<Disassembler> createDisassembler() override {
          return std::make_unique<CapstoneDisassembler>(CS_ARCH_X86, CS_MODE_32);
      }
  };

  class ArchX86_64 : public Architecture {
  public:
      std::string name() const override { return "x86_64"; }
      size_t pointerSize() const override { return 8; }
      Endian endian() const override { return Endian::Little; }

      std::unique_ptr<Disassembler> createDisassembler() override {
          return std::make_unique<CapstoneDisassembler>(CS_ARCH_X86, CS_MODE_64);
      }
  };

  // ==================== 使用示例 ====================
  #include "arch_x86.h"
  #include <iostream>

  int main() {
      ArchX86_64 arch;
      auto disasm = arch.createDisassembler();

      // mov rax, rbx; ret
      std::vector<uint8_t> code = {0x48, 0x89, 0xd8, 0xc3};

      auto result = disasm->disassemble(code, 0x1000);

      for (const auto& insn : result.instructions) {
          std::cout << std::hex << insn.address << ": " << insn.text() << "\n";
      }
      // 输出:
      // 1000: mov rax, rbx
      // 1003: ret
  }

  ---
  文件结构

  include/
  ├── disassembler.h
  ├── capstone_disasm.h
  ├── architecture.h
  └── arch_x86.h

  之后加 ARM 就新建 arch_arm.h，实现 ArchARM 即可。

> Disassembler 应该和Architecture 还是BinaryModule， 绑定一下

● 两者职责不同，Disassembler 由 Architecture 创建，但 BinaryModule 持有实例：

  关系梳理

  Architecture  ──创建──▶  Disassembler
                                │
                                │ 持有/使用
                                ▼
                          BinaryModule

  ---
  推荐设计

  class BinaryModule {
  public:
      BinaryModule(std::vector<uint8_t> data, std::shared_ptr<Architecture> arch)
          : data_(std::move(data))
          , arch_(std::move(arch))
          , disasm_(arch_->createDisassembler())  // 创建一次，复用
      {}

      // 对外接口：反汇编指定地址
      DisassembleResult disassembleAt(uint64_t addr, size_t max_insns = 0) {
          auto offset = addressToOffset(addr);
          std::span<const uint8_t> code{data_.data() + offset, data_.size() - offset};
          return disasm_->disassemble(code, addr);
      }

      Architecture& arch() const { return *arch_; }

  private:
      std::vector<uint8_t> data_;
      std::shared_ptr<Architecture> arch_;
      std::unique_ptr<Disassembler> disasm_;  // 复用，避免反复创建
  };

  ---
  为什么这样设计

  | 问题                          | 答案                           |
  |-------------------------------|--------------------------------|
  | 谁知道怎么创建 Disassembler？ | Architecture（知道 arch/mode） |
  | 谁需要用 Disassembler？       | BinaryModule（有数据）         |
  | Disassembler 能复用吗？       | 能，创建一次，多次调用         |

  ---
  使用示例

  auto arch = std::make_shared<ArchX86_64>();
  auto module = BinaryModule(loadFile("test.exe"), arch);

  // 用户只管调用，不关心 Disassembler
  auto result = module.disassembleAt(0x401000);

  for (const auto& insn : result.instructions) {
      std::cout << insn.text() << "\n";
  }

  ---
  如果未来加 Assembler

  同样模式：

  class BinaryModule {
      std::unique_ptr<Disassembler> disasm_;
      std::unique_ptr<Assembler> asm_;  // 按需创建

  public:
      void patchAt(uint64_t addr, const std::string& asm_text) {
          if (!asm_) {
              asm_ = arch_->createAssembler();
          }
          auto result = asm_->assemble(asm_text, addr);
          // 写入 data_...
      }
  };

> castone 如何获取x86架构 最长指令长度？

● Capstone 没有提供这个 API。x86 最长指令长度是架构规范定义的常量：15 字节。

  ---
  解决方案

  自己在 Architecture 里定义：

  class Architecture {
  public:
      virtual size_t maxInstructionSize() const = 0;
      // ...
  };

  class ArchX86_64 : public Architecture {
  public:
      size_t maxInstructionSize() const override {
          return 15;  // x86/x64 架构硬性规定
      }
  };

  class ArchARM64 : public Architecture {
  public:
      size_t maxInstructionSize() const override {
          return 4;   // ARM64 固定 4 字节
      }
  };

  ---
  各架构最长指令长度

  | 架构    | 最长指令        | 说明             |
  |---------|-----------------|------------------|
  | x86/x64 | 15 字节         | Intel 手册规定   |
  | ARM     | 4 字节          | 固定长度         |
  | ARM64   | 4 字节          | 固定长度         |
  | Thumb   | 4 字节          | 2 或 4 字节      |
  | MIPS    | 4 字节          | 固定长度         |
  | RISC-V  | 4 字节 (或更长) | 标准 4，扩展可变 |

  ---
  使用场景

  // 反汇编单条指令时，确保读取足够数据
  size_t bytesToRead = arch.maxInstructionSize();
  auto code = module.readBytes(addr, bytesToRead);
  auto result = disasm->disassemble(code, addr);

  这个值是架构层面的，放在 Architecture 里合适。

> LIEF::Binary 可以通过rva 读取指定位置的数据吗？

● 可以，用 get_content_from_virtual_address()：

  #include <LIEF/LIEF.hpp>

  auto binary = LIEF::Parser::parse("test.exe");

  // 方式1：直接用 VA（RVA + ImageBase）
  uint64_t rva = 0x1000;
  uint64_t va = binary->imagebase() + rva;
  auto data = binary->get_content_from_virtual_address(va, 16);

  // data 是 std::vector<uint8_t>
  for (auto byte : data) {
      printf("%02x ", byte);
  }

  ---
  如果只有 RVA

  // PE 文件
  auto* pe = dynamic_cast<LIEF::PE::Binary*>(binary.get());
  uint64_t va = pe->imagebase() + rva;
  auto data = pe->get_content_from_virtual_address(va, size);

  // ELF 文件（通常 imagebase 是 0 或加载地址）
  auto* elf = dynamic_cast<LIEF::ELF::Binary*>(binary.get());
  auto data = elf->get_content_from_virtual_address(rva, size);

  ---
  封装建议

  class BinaryModule {
  public:
      std::vector<uint8_t> readAt(uint64_t rva, size_t size) {
          uint64_t va = binary_->imagebase() + rva;
          return binary_->get_content_from_virtual_address(va, size);
      }

  private:
      std::unique_ptr<LIEF::Binary> binary_;
  };

  ---
  注意事项

  | 情况            | 行为               |
  |-----------------|--------------------|
  | 地址有效        | 返回数据           |
  | 地址无效/未映射 | 返回空 vector      |
  | 跨 section 读取 | 可能返回不完整数据 |

  建议读之前检查返回的 size 是否符合预期。

> 如何要服用，抽象的代码写在父类，具体可变的代码写在子类实现，
拿子类调用父类的代码，位置应该在一开始，还是结尾，这个有标准和规范吗？， bool PEBinaryModule::load(const
std::string& path)
{
  binary_ = LIEF::PE::Parser::parse(path);
  if(!binary_)
    return false;


  return __super::load(path);
}

● 没有统一标准，取决于语义和依赖关系：

  两种模式

  模式1：先父类（前置检查/初始化）

  bool PEBinaryModule::load(const std::string& path) {
      // 父类先做通用检查/初始化
      if (!BinaryModule::load(path))
          return false;

      // 子类再做特定工作
      binary_ = LIEF::PE::Parser::parse(path);
      return binary_ != nullptr;
  }

  适用：父类做前置验证（文件存在？权限？）

  模式2：先子类（当前写法）

  bool PEBinaryModule::load(const std::string& path) {
      // 子类先准备数据
      binary_ = LIEF::PE::Parser::parse(path);
      if (!binary_)
          return false;

      // 父类依赖子类设置的数据
      return BinaryModule::load(path);
  }

  适用：父类的逻辑依赖子类准备的状态

  ---
  更好的设计：模板方法模式

  把"可变部分"分离出来，避免调用顺序问题：

  class BinaryModule {
  public:
      // 固定流程，不可 override
      bool load(const std::string& path) {
          if (!std::filesystem::exists(path))
              return false;

          // 子类实现具体解析
          if (!doLoad(path))
              return false;

          // 通用后处理
          analyzeArchitecture();
          return true;
      }

  protected:
      // 子类只实现这个
      virtual bool doLoad(const std::string& path) = 0;
  };

  class PEBinaryModule : public BinaryModule {
  protected:
      bool doLoad(const std::string& path) override {
          binary_ = LIEF::PE::Parser::parse(path);
          return binary_ != nullptr;
      }
  };

  优点：子类不用关心调用顺序，父类控制流程。

  ---
  另外

  __super 是 MSVC 扩展，不可移植。建议用显式类名：

  // ❌ MSVC only
  return __super::load(path);

  // ✅ 标准 C++
  return BinaryModule::load(path);

  ---
  总结

  | 场景             | 调用顺序             |
  |------------------|----------------------|
  | 父类做前置检查   | 先父类               |
  | 父类依赖子类状态 | 先子类               |
  | 想避免混乱       | 模板方法模式（推荐） |

> 二进制分析，存储地址使用rva好还是va好？

● 两者各有场景，但推荐内部用 RVA，对外显示 VA：

  对比

  |             | RVA              | VA                  |
  |-------------|------------------|---------------------|
  | 定义        | 相对于 ImageBase | ImageBase + RVA     |
  | 模块重定位  | 不变 ✅          | 会变                |
  | 多模块分析  | 需要配合模块ID   | 天然唯一            |
  | PE 内部结构 | 原生使用         | 需转换              |
  | 用户熟悉度  | 较低             | 高（调试器显示 VA） |

  ---
  推荐方案

  struct Address {
      uint64_t rva;                    // 内部存储 RVA
      BinaryModule* module = nullptr;  // 所属模块

      uint64_t va() const {
          return module ? module->imageBase() + rva : rva;
      }
  };

  内部存 RVA，按需算 VA。

  ---
  理由

  1. 存储稳定性

  // ASLR 开启，每次加载 ImageBase 不同
  // 第一次运行：ImageBase = 0x00400000, func VA = 0x00401000
  // 第二次运行：ImageBase = 0x10000000, func VA = 0x10001000

  // RVA 始终是 0x1000，分析结果可复用

  2. PE 格式原生 RVA

  // 导入表、导出表、重定位表全是 RVA
  auto exports = pe->get_export();
  for (auto& entry : exports.entries()) {
      uint32_t rva = entry.address();  // 原生就是 RVA
  }

  3. 多模块支持

  // 单用 VA 可能冲突
  // module_a.dll VA 0x10001000
  // module_b.dll VA 0x10001000  // 同一个地址！

  // RVA + Module 组合唯一
  struct GlobalAddress {
      ModuleId module;
      uint64_t rva;
  };

  ---
  实际实现

  class BinaryModule {
  public:
      uint64_t imageBase() const;

      // 内部接口用 RVA
      std::vector<uint8_t> readAt(uint64_t rva, size_t size);
      DisassembleResult disassembleAt(uint64_t rva);

      // 转换接口
      uint64_t rvaToVa(uint64_t rva) const { return imageBase() + rva; }
      uint64_t vaToRva(uint64_t va) const { return va - imageBase(); }
  };

  // UI/输出层显示 VA
  void printInstruction(const Instruction& insn, BinaryModule& mod) {
      uint64_t va = mod.rvaToVa(insn.address);
      printf("%016llx: %s\n", va, insn.text().c_str());
  }

  ---
  简单场景

  如果只分析单个模块且不考虑 ASLR，直接用 VA 也行，省心：

  // 简单粗暴，够用
  uint64_t address;  // 直接存 VA

  你的工具需要支持多模块分析吗？

> 二进制分析中如何划分一个基本块，

● 基本块（Basic Block）定义：单入口、单出口的连续指令序列。

  边界规则

  基本块开始（Leader）

  1. 函数入口点
  2. 跳转目标地址（被 jmp/jcc 指向）
  3. 条件跳转的下一条指令（fall-through）
  4. call 的下一条指令（可选）

  基本块结束（Terminator）

  1. 无条件跳转 jmp
  2. 条件跳转 jcc（je, jne, jl...）
  3. 返回 ret
  4. 间接跳转 jmp rax
  5. 调用 call（取决于策略）

  ---
  图解

                ┌─────────────────┐
                │ 0x1000: push rbp│
                │ 0x1001: mov ... │
                │ 0x1004: cmp ... │
                │ 0x1007: je 0x1020│ ← 条件跳转，块结束
                └────────┬────────┘
                   ┌─────┴─────┐
                   ▼           ▼
      ┌────────────────┐  ┌────────────────┐
      │ 0x1009: mov ...│  │ 0x1020: xor ...│ ← 跳转目标，新块开始
      │ 0x100C: add ...│  │ 0x1023: ret    │
      │ 0x100F: jmp 1020│  └────────────────┘
      └────────────────┘

  ---
  算法实现

  struct BasicBlock {
      uint64_t start_rva;
      uint64_t end_rva;
      std::vector<Instruction> instructions;

      enum class EndType {
          Jump,           // jmp
          ConditionalJump,// jcc
          Return,         // ret
          Call,           // call（可选是否分割）
          FallThrough,    // 被其他跳转目标截断
          Invalid,        // 非法指令
      } end_type;

      std::vector<uint64_t> successors;  // 后继块地址
  };

  class BasicBlockBuilder {
  public:
      std::vector<BasicBlock> build(uint64_t entry_rva) {
          std::set<uint64_t> leaders;      // 所有块起始地址
          std::queue<uint64_t> worklist;

          // Pass 1: 收集所有 leader
          leaders.insert(entry_rva);
          worklist.push(entry_rva);

          while (!worklist.empty()) {
              uint64_t addr = worklist.front();
              worklist.pop();

              while (true) {
                  auto insn = disassembleOne(addr);
                  if (!insn) break;

                  if (isConditionalJump(insn)) {
                      uint64_t target = getJumpTarget(insn);
                      uint64_t fallthrough = addr + insn.size;

                      if (leaders.insert(target).second)
                          worklist.push(target);
                      if (leaders.insert(fallthrough).second)
                          worklist.push(fallthrough);
                      break;
                  }

                  if (isUnconditionalJump(insn)) {
                      uint64_t target = getJumpTarget(insn);
                      if (leaders.insert(target).second)
                          worklist.push(target);
                      break;
                  }

                  if (isReturn(insn)) {
                      break;
                  }

                  addr += insn.size;
              }
          }

          // Pass 2: 根据 leaders 构建基本块
          return buildBlocks(leaders);
      }
  };

  ---
  关于 call 的处理

  有两种策略：

  | 策略   | call 处理     | 适用场景                   |
  |--------|---------------|----------------------------|
  | 不分割 | call 不结束块 | 简单分析，假设 call 必返回 |
  | 分割   | call 结束块   | 精确分析，处理 noreturn    |

  // 策略1：call 不分割（常见）
  // 块内: [push, mov, call printf, mov, ret]

  // 策略2：call 分割
  // 块1: [push, mov, call printf]
  // 块2: [mov, ret]

  推荐先用策略1，遇到 exit()、abort() 等 noreturn 函数再特殊处理。

  ---
  常用指令分类（x86）

  bool isConditionalJump(const Instruction& insn) {
      // je, jne, jl, jg, jle, jge, jb, ja, js, jns...
      return insn.mnemonic[0] == 'j' && insn.mnemonic != "jmp";
  }

  bool isUnconditionalJump(const Instruction& insn) {
      return insn.mnemonic == "jmp";
  }

  bool isReturn(const Instruction& insn) {
      return insn.mnemonic == "ret" || insn.mnemonic == "retf";
  }

  bool isCall(const Instruction& insn) {
      return insn.mnemonic == "call";
  }

  你需要实现完整的 CFG（控制流图）构建吗？

> 实现完整的 CFG 控制流图构建

● // ==================== cfg_types.h ====================
  #pragma once
  #include <cstdint>
  #include <vector>
  #include <string>
  #include <memory>
  #include <unordered_map>
  #include <unordered_set>
  #include <set>
  #include <queue>

  struct Instruction {
      uint64_t address;
      size_t size;
      std::string mnemonic;
      std::string operands;
      std::vector<uint8_t> bytes;

      std::string text() const { return mnemonic + " " + operands; }
      uint64_t nextAddress() const { return address + size; }
  };

  enum class EdgeType {
      FallThrough,      // 顺序执行
      ConditionalTrue,  // 条件跳转 - 跳转
      ConditionalFalse, // 条件跳转 - 不跳转
      Unconditional,    // 无条件跳转
      Call,             // 调用
      Return,           // 返回
  };

  enum class BlockEndType {
      Invalid,
      FallThrough,       // 被其他 leader 截断
      ConditionalJump,   // jcc
      UnconditionalJump, // jmp
      IndirectJump,      // jmp rax
      Call,              // call（可选分割）
      Return,            // ret
  };

  // ==================== basic_block.h ====================
  #pragma once
  #include "cfg_types.h"

  class BasicBlock {
  public:
      uint64_t startAddress() const { return start_; }
      uint64_t endAddress() const { return end_; }
      size_t size() const { return end_ - start_; }

      const std::vector<Instruction>& instructions() const { return instructions_; }
      BlockEndType endType() const { return end_type_; }

      // 后继/前驱
      const std::vector<uint64_t>& successors() const { return successors_; }
      const std::vector<uint64_t>& predecessors() const { return predecessors_; }

      void addSuccessor(uint64_t addr) { successors_.push_back(addr); }
      void addPredecessor(uint64_t addr) { predecessors_.push_back(addr); }

  private:
      friend class CFGBuilder;

      uint64_t start_ = 0;
      uint64_t end_ = 0;
      std::vector<Instruction> instructions_;
      BlockEndType end_type_ = BlockEndType::Invalid;
      std::vector<uint64_t> successors_;
      std::vector<uint64_t> predecessors_;
  };

  // ==================== cfg.h ====================
  #pragma once
  #include "basic_block.h"
  #include <optional>

  struct CFGEdge {
      uint64_t from;
      uint64_t to;
      EdgeType type;
  };

  class CFG {
  public:
      uint64_t entryAddress() const { return entry_; }

      BasicBlock* blockAt(uint64_t addr) {
          auto it = blocks_.find(addr);
          return it != blocks_.end() ? it->second.get() : nullptr;
      }

      const BasicBlock* blockAt(uint64_t addr) const {
          auto it = blocks_.find(addr);
          return it != blocks_.end() ? it->second.get() : nullptr;
      }

      // 查找包含某地址的块
      BasicBlock* blockContaining(uint64_t addr) {
          for (auto& [start, block] : blocks_) {
              if (addr >= block->startAddress() && addr < block->endAddress())
                  return block.get();
          }
          return nullptr;
      }

      const std::vector<CFGEdge>& edges() const { return edges_; }

      // 遍历所有块
      template<typename Fn>
      void forEachBlock(Fn&& fn) const {
          for (const auto& [addr, block] : blocks_) {
              fn(*block);
          }
      }

      size_t blockCount() const { return blocks_.size(); }
      size_t edgeCount() const { return edges_.size(); }

  private:
      friend class CFGBuilder;

      uint64_t entry_ = 0;
      std::unordered_map<uint64_t, std::unique_ptr<BasicBlock>> blocks_;
      std::vector<CFGEdge> edges_;
  };

  // ==================== cfg_builder.h ====================
  #pragma once
  #include "cfg.h"
  #include "disassembler.h"
  #include <functional>

  class CFGBuilder {
  public:
      using ReadMemoryFn = std::function<std::vector<uint8_t>(uint64_t addr, size_t size)>;

      CFGBuilder(Disassembler& disasm, ReadMemoryFn read_mem, size_t max_insn_size = 15)
          : disasm_(disasm)
          , read_mem_(std::move(read_mem))
          , max_insn_size_(max_insn_size)
      {}

      std::unique_ptr<CFG> build(uint64_t entry);

  private:
      // 指令分类
      static bool isConditionalJump(const Instruction& insn);
      static bool isUnconditionalJump(const Instruction& insn);
      static bool isIndirectJump(const Instruction& insn);
      static bool isCall(const Instruction& insn);
      static bool isReturn(const Instruction& insn);
      static std::optional<uint64_t> getJumpTarget(const Instruction& insn);

      // 反汇编单条指令
      std::optional<Instruction> disassembleOne(uint64_t addr);

      // Pass 1: 收集所有 leader
      void collectLeaders(uint64_t entry);

      // Pass 2: 构建基本块
      void buildBlocks();

      // Pass 3: 连接边
      void connectEdges();

  private:
      Disassembler& disasm_;
      ReadMemoryFn read_mem_;
      size_t max_insn_size_;

      std::set<uint64_t> leaders_;
      std::unordered_set<uint64_t> visited_;
      std::unique_ptr<CFG> cfg_;
  };

  // ==================== cfg_builder.cpp ====================
  #include "cfg_builder.h"
  #include <algorithm>

  std::unique_ptr<CFG> CFGBuilder::build(uint64_t entry) {
      cfg_ = std::make_unique<CFG>();
      cfg_->entry_ = entry;

      leaders_.clear();
      visited_.clear();

      // 三遍扫描
      collectLeaders(entry);
      buildBlocks();
      connectEdges();

      return std::move(cfg_);
  }

  void CFGBuilder::collectLeaders(uint64_t entry) {
      std::queue<uint64_t> worklist;

      leaders_.insert(entry);
      worklist.push(entry);

      while (!worklist.empty()) {
          uint64_t addr = worklist.front();
          worklist.pop();

          if (visited_.count(addr))
              continue;
          visited_.insert(addr);

          // 线性扫描直到遇到控制流转移
          while (true) {
              // 检查是否踩到其他 leader（被截断）
              if (addr != entry && leaders_.count(addr)) {
                  break;
              }

              auto insn = disassembleOne(addr);
              if (!insn) break;

              if (isConditionalJump(*insn)) {
                  auto target = getJumpTarget(*insn);
                  uint64_t fallthrough = insn->nextAddress();

                  if (target && leaders_.insert(*target).second) {
                      worklist.push(*target);
                  }
                  if (leaders_.insert(fallthrough).second) {
                      worklist.push(fallthrough);
                  }
                  break;
              }

              if (isUnconditionalJump(*insn)) {
                  auto target = getJumpTarget(*insn);
                  if (target && leaders_.insert(*target).second) {
                      worklist.push(*target);
                  }
                  break;
              }

              if (isReturn(*insn) || isIndirectJump(*insn)) {
                  break;
              }

              // call 不分割块，但标记下一条为潜在 leader（可选）
              // if (isCall(*insn)) {
              //     leaders_.insert(insn->nextAddress());
              // }

              addr = insn->nextAddress();
          }
      }
  }

  void CFGBuilder::buildBlocks() {
      for (uint64_t leader : leaders_) {
          auto block = std::make_unique<BasicBlock>();
          block->start_ = leader;

          uint64_t addr = leader;

          while (true) {
              auto insn = disassembleOne(addr);
              if (!insn) {
                  block->end_type_ = BlockEndType::Invalid;
                  break;
              }

              block->instructions_.push_back(*insn);
              uint64_t next = insn->nextAddress();

              // 判断块结束条件
              if (isConditionalJump(*insn)) {
                  block->end_type_ = BlockEndType::ConditionalJump;

                  // 添加后继
                  if (auto target = getJumpTarget(*insn)) {
                      block->successors_.push_back(*target);
                  }
                  block->successors_.push_back(next);  // fallthrough
                  break;
              }

              if (isUnconditionalJump(*insn)) {
                  if (isIndirectJump(*insn)) {
                      block->end_type_ = BlockEndType::IndirectJump;
                  } else {
                      block->end_type_ = BlockEndType::UnconditionalJump;
                      if (auto target = getJumpTarget(*insn)) {
                          block->successors_.push_back(*target);
                      }
                  }
                  break;
              }

              if (isReturn(*insn)) {
                  block->end_type_ = BlockEndType::Return;
                  break;
              }

              // 被下一个 leader 截断
              if (leaders_.count(next)) {
                  block->end_type_ = BlockEndType::FallThrough;
                  block->successors_.push_back(next);
                  break;
              }

              addr = next;
          }

          block->end_ = block->instructions_.empty()
              ? leader
              : block->instructions_.back().nextAddress();

          cfg_->blocks_[leader] = std::move(block);
      }
  }

  void CFGBuilder::connectEdges() {
      for (auto& [addr, block] : cfg_->blocks_) {
          for (uint64_t succ_addr : block->successors_) {
              auto* succ = cfg_->blockAt(succ_addr);
              if (succ) {
                  succ->addPredecessor(addr);
              }

              // 确定边类型
              EdgeType edge_type;
              switch (block->end_type_) {
                  case BlockEndType::ConditionalJump:
                      if (succ_addr == block->instructions_.back().nextAddress()) {
                          edge_type = EdgeType::ConditionalFalse;
                      } else {
                          edge_type = EdgeType::ConditionalTrue;
                      }
                      break;
                  case BlockEndType::UnconditionalJump:
                      edge_type = EdgeType::Unconditional;
                      break;
                  case BlockEndType::FallThrough:
                      edge_type = EdgeType::FallThrough;
                      break;
                  default:
                      edge_type = EdgeType::FallThrough;
              }

              cfg_->edges_.push_back({addr, succ_addr, edge_type});
          }
      }
  }

  // ==================== 指令分类实现 ====================

  bool CFGBuilder::isConditionalJump(const Instruction& insn) {
      const auto& m = insn.mnemonic;
      if (m.empty() || m[0] != 'j') return false;
      if (m == "jmp") return false;

      // je, jne, jl, jle, jg, jge, jb, jbe, ja, jae, js, jns, jo, jno, jp, jnp
      // jcxz, jecxz, jrcxz, loop, loope, loopne
      return true;
  }

  bool CFGBuilder::isUnconditionalJump(const Instruction& insn) {
      return insn.mnemonic == "jmp";
  }

  bool CFGBuilder::isIndirectJump(const Instruction& insn) {
      if (insn.mnemonic != "jmp") return false;
      // 检查操作数是否是寄存器或内存
      const auto& op = insn.operands;
      return !op.empty() && (op.find("0x") == std::string::npos || op.find('[') != std::string::npos);
  }

  bool CFGBuilder::isCall(const Instruction& insn) {
      return insn.mnemonic == "call";
  }

  bool CFGBuilder::isReturn(const Instruction& insn) {
      return insn.mnemonic == "ret" || insn.mnemonic == "retn" || insn.mnemonic == "retf";
  }

  std::optional<uint64_t> CFGBuilder::getJumpTarget(const Instruction& insn) {
      // 简单解析：假设操作数是 "0x1234" 形式
      const auto& op = insn.operands;
      if (op.empty()) return std::nullopt;

      try {
          return std::stoull(op, nullptr, 0);
      } catch (...) {
          return std::nullopt;  // 间接跳转，无法静态解析
      }
  }

  std::optional<Instruction> CFGBuilder::disassembleOne(uint64_t addr) {
      auto code = read_mem_(addr, max_insn_size_);
      if (code.empty()) return std::nullopt;

      auto result = disasm_.disassemble(code, addr);
      if (result.instructions.empty()) return std::nullopt;

      return result.instructions[0];
  }

  // ==================== 使用示例 ====================
  #include "cfg_builder.h"
  #include "arch_x86.h"

  int main() {
      // 设置
      ArchX86_64 arch;
      auto disasm = arch.createDisassembler();

      // 模拟二进制数据
      std::vector<uint8_t> binary = { /* ... */ };
      uint64_t base_addr = 0x401000;

      auto read_mem = [&](uint64_t addr, size_t size) -> std::vector<uint8_t> {
          uint64_t offset = addr - base_addr;
          if (offset >= binary.size()) return {};
          size_t actual = std::min(size, binary.size() - offset);
          return {binary.begin() + offset, binary.begin() + offset + actual};
      };

      // 构建 CFG
      CFGBuilder builder(*disasm, read_mem);
      auto cfg = builder.build(0x401000);

      // 打印结果
      printf("CFG: %zu blocks, %zu edges\n", cfg->blockCount(), cfg->edgeCount());

      cfg->forEachBlock([](const BasicBlock& block) {
          printf("\nBlock 0x%llx - 0x%llx:\n", block.startAddress(), block.endAddress());
          for (const auto& insn : block.instructions()) {
              printf("  0x%llx: %s\n", insn.address, insn.text().c_str());
          }
          printf("  -> successors:");
          for (auto succ : block.successors()) {
              printf(" 0x%llx", succ);
          }
          printf("\n");
      });
  }

  ---
  输出示例

  CFG: 4 blocks, 5 edges

  Block 0x401000 - 0x401010:
    0x401000: push rbp
    0x401001: mov rbp, rsp
    0x401004: cmp edi, 0
    0x401007: je 0x401020
    -> successors: 0x401020 0x401009

  Block 0x401009 - 0x401015:
    0x401009: mov eax, 1
    0x40100e: jmp 0x401025
    -> successors: 0x401025

  Block 0x401020 - 0x401025:
    0x401020: xor eax, eax
    -> successors: 0x401025

  Block 0x401025 - 0x40102a:
    0x401025: pop rbp
    0x401026: ret
    -> successors:

  ---
  扩展方向

  | 功能                    | 说明           |
  |-------------------------|----------------|
  | 支配树 (Dominator Tree) | 用于优化和分析 |
  | 循环检测                | 识别 back edge |
  | 间接跳转解析            | 结合数据流分析 |
  | 导出 Graphviz           | 可视化 CFG     |

  需要实现 Graphviz 导出来可视化吗？

> 构建基本块 worklist 和leaders都是什么意思和作用

● Leaders（领导者）

  定义：基本块的起始地址集合。

  每个 leader 就是一个基本块的第一条指令地址。

  std::set<uint64_t> leaders_;  // 存储所有基本块的起始地址

  什么地址会成为 Leader

  0x1000: push rbp        ← Leader（函数入口）
  0x1001: mov rbp, rsp
  0x1004: cmp eax, 0
  0x1007: je 0x1020       → 产生两个新 Leader
                  │
          ┌───────┴───────┐
          ▼               ▼
  0x1009: mov eax, 1  ← Leader（fallthrough）
  0x100E: jmp 0x1025
          │
          │           0x1020: xor eax, eax  ← Leader（跳转目标）
          │           0x1023: nop
          │               │
          ▼               ▼
  0x1025: pop rbp     ← Leader（跳转目标）
  0x1026: ret

  Leaders = {0x1000, 0x1009, 0x1020, 0x1025}

  ---
  Worklist（工作队列）

  定义：待处理的地址队列，用于 BFS 遍历控制流。

  std::queue<uint64_t> worklist;  // 待分析的起始地址

  工作流程

  初始状态:
    leaders = {0x1000}
    worklist = [0x1000]

  第1轮: 处理 0x1000
    扫描到 je 0x1020
    发现新 leader: 0x1009 (fallthrough), 0x1020 (target)
    leaders = {0x1000, 0x1009, 0x1020}
    worklist = [0x1009, 0x1020]

  第2轮: 处理 0x1009
    扫描到 jmp 0x1025
    发现新 leader: 0x1025
    leaders = {0x1000, 0x1009, 0x1020, 0x1025}
    worklist = [0x1020, 0x1025]

  第3轮: 处理 0x1020
    扫描到 fallthrough 到 0x1025
    0x1025 已在 leaders，不重复添加
    worklist = [0x1025]

  第4轮: 处理 0x1025
    扫描到 ret，无后继
    worklist = []

  结束！

  ---
  形象比喻

  | 概念     | 比喻                 |
  |----------|----------------------|
  | Leaders  | 地图上标记的所有路口 |
  | Worklist | 待探索的路口队列     |
  | Visited  | 已走过的路口         |

  探险过程:
  1. 从入口（0x1000）出发
  2. 走到岔路口（je），标记两个新路口
  3. 把新路口加入待探索队列
  4. 从队列取下一个，继续探索
  5. 直到队列为空

  ---
  为什么需要 Worklist

  因为控制流不是线性的：

  不用 worklist（错误）:
    线性扫描 0x1000 → 0x1001 → ... → 0x1007 (je 0x1020)
    然后呢？去 0x1009 还是 0x1020？漏掉一个分支！

  用 worklist（正确）:
    遇到分支 → 两个目标都入队 → 保证都能遍历到

  ---
  简化伪代码

  void collectLeaders(uint64_t entry) {
      leaders.insert(entry);      // 入口是第一个 leader
      worklist.push(entry);       // 从入口开始探索

      while (!worklist.empty()) {
          addr = worklist.pop();
          if (visited[addr]) continue;
          visited[addr] = true;

          // 线性扫描
          while (true) {
              insn = disasm(addr);

              if (insn 是条件跳转) {
                  // 发现两个新 leader
                  addLeader(跳转目标);
                  addLeader(下一条指令);
                  break;
              }
              if (insn 是无条件跳转) {
                  addLeader(跳转目标);
                  break;
              }
              if (insn 是 ret) {
                  break;  // 无后继
              }

              addr = 下一条指令;
          }
      }
  }

  void addLeader(uint64_t addr) {
      if (leaders.insert(addr).second) {  // 新发现的
          worklist.push(addr);             // 加入待探索
      }
  }

  ---
  总结

  | 概念     | 作用                       |
  |----------|----------------------------|
  | Leaders  | 记录所有基本块的起始地址   |
  | Worklist | BFS 队列，确保遍历所有分支 |
  | Visited  | 防止重复处理同一地址       |

  三者配合实现完整的控制流发现。

> c++ 有没有简单绘制，可以把基本块和CFG都绘制出来，最好越轻量越好，只是用于测试验证

● 最简单的方案：导出 Graphviz DOT 格式，零依赖。

  方案1：导出 DOT（推荐）

  // ==================== cfg_export.h ====================
  #pragma once
  #include "cfg.h"
  #include <sstream>
  #include <iomanip>

  class CFGExporter {
  public:
      static std::string toDot(const CFG& cfg) {
          std::ostringstream ss;

          ss << "digraph CFG {\n";
          ss << "  node [shape=box, fontname=\"Courier\", fontsize=10];\n";
          ss << "  edge [fontsize=8];\n\n";

          // 绘制节点
          cfg.forEachBlock([&](const BasicBlock& block) {
              ss << "  \"" << hex(block.startAddress()) << "\" [label=\"";

              // 块内指令
              for (const auto& insn : block.instructions()) {
                  ss << hex(insn.address) << ": " << escape(insn.text()) << "\\l";
              }

              ss << "\"];\n";
          });

          ss << "\n";

          // 绘制边
          for (const auto& edge : cfg.edges()) {
              ss << "  \"" << hex(edge.from) << "\" -> \"" << hex(edge.to) << "\"";

              // 边标签和颜色
              switch (edge.type) {
                  case EdgeType::ConditionalTrue:
                      ss << " [color=green, label=\"T\"]";
                      break;
                  case EdgeType::ConditionalFalse:
                      ss << " [color=red, label=\"F\"]";
                      break;
                  case EdgeType::Unconditional:
                      ss << " [color=blue]";
                      break;
                  default:
                      break;
              }
              ss << ";\n";
          }

          ss << "}\n";
          return ss.str();
      }

      // 保存到文件
      static void saveDot(const CFG& cfg, const std::string& path) {
          std::ofstream f(path);
          f << toDot(cfg);
      }

  private:
      static std::string hex(uint64_t addr) {
          std::ostringstream ss;
          ss << "0x" << std::hex << addr;
          return ss.str();
      }

      static std::string escape(const std::string& s) {
          std::string out;
          for (char c : s) {
              if (c == '"') out += "\\\"";
              else if (c == '\\') out += "\\\\";
              else out += c;
          }
          return out;
      }
  };

  使用

  // 导出
  CFGExporter::saveDot(*cfg, "output.dot");

  // 命令行渲染
  // dot -Tpng output.dot -o output.png
  // dot -Tsvg output.dot -o output.svg

  在线预览（无需安装）

  把 DOT 内容粘贴到：https://dreampuf.github.io/GraphvizOnline

  ---
  方案2：ASCII 打印（更轻量）

  class CFGPrinter {
  public:
      static void print(const CFG& cfg) {
          printf("=== CFG: %zu blocks, %zu edges ===\n\n",
                 cfg.blockCount(), cfg.edgeCount());

          cfg.forEachBlock([](const BasicBlock& block) {
              // 块头
              printf("+----[ 0x%llx ]", block.startAddress());
              for (auto pred : block.predecessors()) {
                  printf(" <-0x%llx", pred);
              }
              printf("\n");

              // 指令
              for (const auto& insn : block.instructions()) {
                  printf("| 0x%llx: %s\n", insn.address, insn.text().c_str());
              }

              // 后继
              printf("+----> ");
              if (block.successors().empty()) {
                  printf("(exit)\n");
              } else {
                  for (auto succ : block.successors()) {
                      printf("0x%llx ", succ);
                  }
                  printf("\n");
              }
              printf("\n");
          });
      }
  };

  输出效果

  === CFG: 4 blocks, 5 edges ===

  +----[ 0x401000 ]
  | 0x401000: push rbp
  | 0x401001: mov rbp, rsp
  | 0x401004: cmp edi, 0
  | 0x401007: je 0x401020
  +----> 0x401020 0x401009

  +----[ 0x401009 ] <-0x401000
  | 0x401009: mov eax, 1
  | 0x40100e: jmp 0x401025
  +----> 0x401025

  +----[ 0x401020 ] <-0x401000
  | 0x401020: xor eax, eax
  +----> 0x401025

  +----[ 0x401025 ] <-0x401009 <-0x401020
  | 0x401025: pop rbp
  | 0x401026: ret
  +----> (exit)

  ---
  方案3：HTML 导出（可交互）

  static void saveHtml(const CFG& cfg, const std::string& path) {
      std::ofstream f(path);

      f << R"(<!DOCTYPE html>
  <html>
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@hpcc-js/wasm/dist/index.min.js"></script>
    <script src="https://unpkg.com/d3-graphviz@4/build/d3-graphviz.min.js"></script>
  </head>
  <body>
    <div id="graph"></div>
    <script>
      d3.select("#graph").graphviz().renderDot(`)"
        << toDot(cfg)
        << R"(`);
    </script>
  </body>
  </html>)";
  }

  双击打开 HTML 即可在浏览器看到 CFG。

  ---
  总结

  | 方案           | 依赖              | 适用场景  |
  |----------------|-------------------|-----------|
  | DOT + Graphviz | 命令行装 graphviz | 正式输出  |
  | DOT + 在线工具 | 无                | 快速验证  |
  | ASCII          | 无                | 调试打印  |
  | HTML           | 无                | 分享/演示 |

  推荐：开发阶段用 ASCII 打印 + DOT 在线预览，够用且零依赖。



> 如何更好的去分析汇编中 switch语意，分析出所有的case和default

● Switch 编译后有多种形式，需要分别识别：

  编译器生成的三种模式

  1. 跳转表（Jump Table）— 最常见

  // 源码
  switch (x) {
      case 0: foo(); break;
      case 1: bar(); break;
      case 2: baz(); break;
      default: def(); break;
  }

  ; 编译后 (x86-64)
      cmp  edi, 2           ; 检查上界
      ja   default_label    ; x > 2 跳 default

      lea  rax, [rip + jump_table]
      movsxd rcx, dword ptr [rax + rdi*4]  ; 读取跳转表
      add  rcx, rax
      jmp  rcx              ; 间接跳转

  jump_table:
      .long case_0 - jump_table
      .long case_1 - jump_table
      .long case_2 - jump_table

  2. if-else 链

      cmp  edi, 0
      je   case_0
      cmp  edi, 1
      je   case_1
      cmp  edi, 100         ; 值分散
      je   case_100
      jmp  default_label

  3. 二分查找（case 较多且分散）

      cmp  edi, 50
      jl   check_lower
      jg   check_higher
      ; case 50 处理

  ---
  跳转表分析算法

  struct SwitchInfo {
      uint64_t switch_addr;        // switch 指令地址
      uint64_t table_addr;         // 跳转表地址
      uint64_t default_addr;       // default 地址
      int64_t min_case;            // 最小 case 值
      int64_t max_case;            // 最大 case 值
      std::vector<std::pair<int64_t, uint64_t>> cases;  // {case值, 目标地址}
  };

  class SwitchAnalyzer {
  public:
      std::optional<SwitchInfo> analyze(const BasicBlock& block,
                                         const CFG& cfg,
                                         ReadMemoryFn read_mem) {
          auto& insns = block.instructions();
          if (insns.size() < 3) return std::nullopt;

          // 模式匹配：寻找跳转表特征
          // 1. cmp reg, imm      (边界检查)
          // 2. ja/jb default     (跳 default)
          // 3. ... 计算 ...
          // 4. jmp reg/[mem]     (间接跳转)

          const Instruction* bound_check = nullptr;
          const Instruction* default_jump = nullptr;
          const Instruction* indirect_jmp = nullptr;
          uint64_t table_base = 0;

          for (size_t i = 0; i < insns.size(); i++) {
              const auto& insn = insns[i];

              // 找边界检查: cmp edi, N
              if (insn.mnemonic == "cmp" && !bound_check) {
                  bound_check = &insn;
                  continue;
              }

              // 找 default 跳转: ja default
              if ((insn.mnemonic == "ja" || insn.mnemonic == "jb") && bound_check) {
                  default_jump = &insn;
                  continue;
              }

              // 找 lea (跳转表基址): lea rax, [rip + xxx]
              if (insn.mnemonic == "lea") {
                  table_base = parseLeaTarget(insn);
                  continue;
              }

              // 找间接跳转: jmp rax / jmp [rax + rcx*4]
              if (insn.mnemonic == "jmp" && isIndirectJump(insn)) {
                  indirect_jmp = &insn;
                  break;
              }
          }

          if (!bound_check || !indirect_jmp || !table_base) {
              return std::nullopt;
          }

          // 解析跳转表
          return parseJumpTable(bound_check, default_jump, table_base, read_mem);
      }

  private:
      SwitchInfo parseJumpTable(const Instruction* bound_check,
                                 const Instruction* default_jump,
                                 uint64_t table_base,
                                 ReadMemoryFn read_mem) {
          SwitchInfo info;
          info.table_addr = table_base;

          // 从 cmp 指令解析上界: cmp edi, 5 → max_case = 5
          info.max_case = parseCmpImmediate(*bound_check);
          info.min_case = 0;  // 通常从 0 开始

          // 解析 default 地址
          if (default_jump) {
              info.default_addr = parseJumpTarget(*default_jump);
          }

          // 读取跳转表条目
          size_t entry_count = info.max_case - info.min_case + 1;

          for (size_t i = 0; i < entry_count; i++) {
              // 读取 4 字节相对偏移（常见格式）
              auto data = read_mem(table_base + i * 4, 4);
              if (data.size() < 4) break;

              int32_t offset = *reinterpret_cast<int32_t*>(data.data());
              uint64_t target = table_base + offset;

              info.cases.push_back({info.min_case + i, target});
          }

          return info;
      }
  };

  ---
  完整的 Switch 检测器

  class SwitchDetector {
  public:
      struct SwitchCase {
          std::vector<int64_t> values;  // 可能多个值跳同一地址
          uint64_t target_addr;
      };

      struct SwitchStatement {
          uint64_t address;
          std::string switch_var;       // 推测的变量名/寄存器
          std::vector<SwitchCase> cases;
          uint64_t default_addr;
      };

      std::optional<SwitchStatement> detect(const BasicBlock& block,
                                             ReadMemoryFn read_mem) {
          // 检测模式1：跳转表
          if (auto result = detectJumpTable(block, read_mem)) {
              return result;
          }

          // 检测模式2：if-else 链
          if (auto result = detectIfElseChain(block)) {
              return result;
          }

          return std::nullopt;
      }

  private:
      std::optional<SwitchStatement> detectJumpTable(const BasicBlock& block,
                                                      ReadMemoryFn read_mem) {
          // 特征：
          // 1. 块以间接跳转结尾
          // 2. 有边界检查 (cmp + ja/jb)
          // 3. 有 lea 加载表地址

          auto& insns = block.instructions();
          if (insns.empty()) return std::nullopt;

          auto& last = insns.back();
          if (!isIndirectJump(last)) return std::nullopt;

          // 向前搜索特征指令
          std::optional<uint64_t> table_addr;
          std::optional<int64_t> max_value;
          std::optional<uint64_t> default_addr;
          std::string switch_reg;

          for (auto it = insns.rbegin(); it != insns.rend(); ++it) {
              // lea rax, [rip + offset]
              if (it->mnemonic == "lea" && it->operands.find("rip") != std::string::npos) {
                  table_addr = computeRipRelative(*it);
              }

              // cmp edi, N
              if (it->mnemonic == "cmp") {
                  auto [reg, imm] = parseCmpOperands(*it);
                  switch_reg = reg;
                  max_value = imm;
              }

              // ja/jae default_label
              if (it->mnemonic == "ja" || it->mnemonic == "jae") {
                  default_addr = parseJumpTarget(*it);
              }
          }

          if (!table_addr || !max_value) return std::nullopt;

          // 读取跳转表
          SwitchStatement stmt;
          stmt.address = block.startAddress();
          stmt.switch_var = switch_reg;
          stmt.default_addr = default_addr.value_or(0);

          std::unordered_map<uint64_t, std::vector<int64_t>> target_to_values;

          for (int64_t i = 0; i <= *max_value; i++) {
              auto entry = read_mem(*table_addr + i * 4, 4);
              if (entry.size() < 4) break;

              int32_t offset = *reinterpret_cast<int32_t*>(entry.data());
              uint64_t target = *table_addr + offset;

              target_to_values[target].push_back(i);
          }

          // 合并相同目标的 case
          for (auto& [target, values] : target_to_values) {
              stmt.cases.push_back({values, target});
          }

          return stmt;
      }

      std::optional<SwitchStatement> detectIfElseChain(const BasicBlock& block) {
          // 特征：连续的 cmp + je/jne 模式
          auto& insns = block.instructions();

          SwitchStatement stmt;
          stmt.address = block.startAddress();

          std::string switch_reg;

          for (size_t i = 0; i + 1 < insns.size(); i++) {
              auto& cmp = insns[i];
              auto& jcc = insns[i + 1];

              // cmp reg, imm
              // je target
              if (cmp.mnemonic == "cmp" && jcc.mnemonic == "je") {
                  auto [reg, imm] = parseCmpOperands(cmp);

                  if (switch_reg.empty()) {
                      switch_reg = reg;
                  } else if (switch_reg != reg) {
                      // 不同寄存器，可能不是 switch
                      break;
                  }

                  uint64_t target = parseJumpTarget(jcc);
                  stmt.cases.push_back({{imm}, target});
                  i++;  // 跳过 jcc
              }
          }

          if (stmt.cases.size() >= 2) {
              stmt.switch_var = switch_reg;
              // default 是最后的无条件跳转或 fallthrough
              return stmt;
          }

          return std::nullopt;
      }
  };

  ---
  使用示例

  SwitchDetector detector;
  auto result = detector.detect(block, read_mem);

  if (result) {
      printf("Switch at 0x%llx on %s:\n",
             result->address, result->switch_var.c_str());

      for (auto& c : result->cases) {
          printf("  case ");
          for (size_t i = 0; i < c.values.size(); i++) {
              if (i > 0) printf(", ");
              printf("%lld", c.values[i]);
          }
          printf(": goto 0x%llx\n", c.target_addr);
      }

      if (result->default_addr) {
          printf("  default: goto 0x%llx\n", result->default_addr);
      }
  }

  输出：
  Switch at 0x401000 on edi:
    case 0: goto 0x401050
    case 1, 2: goto 0x401060    // 合并的 case
    case 3: goto 0x401070
    default: goto 0x401080

  ---
  难点和边界情况

  | 情况                        | 处理方式                    |
  |-----------------------------|-----------------------------|
  | 稀疏 case（如 0,1,100,200） | 编译器可能用 if-else 或二分 |
  | 负数 case                   | 检查 sub 指令调整偏移       |
  | 跳转表格式（绝对/相对地址） | 读取后判断是否合理          |
  | MSVC vs GCC 差异            | 模式略有不同，需多种特征    |
  | 混淆/手写汇编               | 启发式分析，无法保证        |

  需要我展开讲某个特定编译器的模式吗？


> 我有一个需求，给定一个函数(多个基本块)， 如何trace
一个值(内存/寄存器)，把整个计算赋值过程提升成表达式，更容易分析switch跳转表的情况

● 这是符号执行/数据流分析的核心问题。目标是把指令序列提升为表达式。

  概念示例

  ; 输入
  mov  eax, [rbp-8]           ; 加载 switch 变量
  lea  rcx, [rip+0x1000]      ; 跳转表基址
  movsxd rdx, [rcx+rax*4]     ; 读取表项
  add  rdx, rcx               ; 计算目标
  jmp  rdx

  ; 输出表达式
  jmp_target = table_base + *(int32_t*)(table_base + switch_var * 4)

  ---
  实现：符号表达式系统

  // ==================== expr.h ====================
  #pragma once
  #include <memory>
  #include <string>
  #include <variant>
  #include <vector>

  // 前向声明
  struct Expr;
  using ExprPtr = std::shared_ptr<Expr>;

  // 表达式类型
  enum class ExprKind {
      Const,      // 常量: 0x1000
      Reg,        // 寄存器: rax
      Mem,        // 内存读取: [addr]
      Add,        // 加法: a + b
      Sub,        // 减法: a - b
      Mul,        // 乘法: a * b
      Shl,        // 左移: a << b
      Shr,        // 右移: a >> b
      And,        // 与: a & b
      Or,         // 或: a | b
      Xor,        // 异或: a ^ b
      SignExt,    // 符号扩展
      ZeroExt,    // 零扩展
      Unknown,    // 未知来源
  };

  struct Expr : std::enable_shared_from_this<Expr> {
      ExprKind kind;
      int bit_width = 64;  // 位宽

      // 根据类型存储不同数据
      uint64_t const_val = 0;           // Const
      std::string reg_name;             // Reg
      ExprPtr operand;                  // 一元操作
      ExprPtr left, right;              // 二元操作

      // 工厂方法
      static ExprPtr makeConst(uint64_t val, int bits = 64) {
          auto e = std::make_shared<Expr>();
          e->kind = ExprKind::Const;
          e->const_val = val;
          e->bit_width = bits;
          return e;
      }

      static ExprPtr makeReg(const std::string& name, int bits = 64) {
          auto e = std::make_shared<Expr>();
          e->kind = ExprKind::Reg;
          e->reg_name = name;
          e->bit_width = bits;
          return e;
      }

      static ExprPtr makeMem(ExprPtr addr, int bits = 64) {
          auto e = std::make_shared<Expr>();
          e->kind = ExprKind::Mem;
          e->operand = std::move(addr);
          e->bit_width = bits;
          return e;
      }

      static ExprPtr makeBinary(ExprKind op, ExprPtr l, ExprPtr r) {
          auto e = std::make_shared<Expr>();
          e->kind = op;
          e->left = std::move(l);
          e->right = std::move(r);
          e->bit_width = e->left->bit_width;
          return e;
      }

      static ExprPtr makeUnknown(const std::string& desc = "?") {
          auto e = std::make_shared<Expr>();
          e->kind = ExprKind::Unknown;
          e->reg_name = desc;
          return e;
      }

      // 简化打印
      std::string toString() const;

      // 常量折叠
      ExprPtr simplify() const;

      // 判断是否为常量
      bool isConst() const { return kind == ExprKind::Const; }

      // 提取常量值
      std::optional<uint64_t> getConstValue() const {
          if (kind == ExprKind::Const) return const_val;
          return std::nullopt;
      }
  };

  // ==================== expr.cpp ====================
  #include "expr.h"
  #include <sstream>

  std::string Expr::toString() const {
      switch (kind) {
          case ExprKind::Const:
              return "0x" + std::to_string(const_val);

          case ExprKind::Reg:
              return reg_name;

          case ExprKind::Mem:
              return "[" + operand->toString() + "]";

          case ExprKind::Add:
              return "(" + left->toString() + " + " + right->toString() + ")";

          case ExprKind::Sub:
              return "(" + left->toString() + " - " + right->toString() + ")";

          case ExprKind::Mul:
              return "(" + left->toString() + " * " + right->toString() + ")";

          case ExprKind::Shl:
              return "(" + left->toString() + " << " + right->toString() + ")";

          case ExprKind::And:
              return "(" + left->toString() + " & " + right->toString() + ")";

          case ExprKind::SignExt:
              return "sext(" + operand->toString() + ")";

          case ExprKind::Unknown:
              return reg_name.empty() ? "?" : reg_name;

          default:
              return "???";
      }
  }

  ExprPtr Expr::simplify() const {
      // 常量折叠
      if (kind == ExprKind::Add && left->isConst() && right->isConst()) {
          return makeConst(left->const_val + right->const_val);
      }
      if (kind == ExprKind::Mul && left->isConst() && right->isConst()) {
          return makeConst(left->const_val * right->const_val);
      }

      // x + 0 = x
      if (kind == ExprKind::Add) {
          if (right->isConst() && right->const_val == 0) return left;
          if (left->isConst() && left->const_val == 0) return right;
      }

      // x * 1 = x
      if (kind == ExprKind::Mul) {
          if (right->isConst() && right->const_val == 1) return left;
          if (left->isConst() && left->const_val == 1) return right;
      }

      // x * 0 = 0
      if (kind == ExprKind::Mul) {
          if (right->isConst() && right->const_val == 0) return makeConst(0);
          if (left->isConst() && left->const_val == 0) return makeConst(0);
      }

      return std::const_pointer_cast<Expr>(shared_from_this());
  }

  ---
  符号执行状态

  // ==================== symbolic_state.h ====================
  #pragma once
  #include "expr.h"
  #include <unordered_map>

  class SymbolicState {
  public:
      // 获取寄存器值
      ExprPtr getReg(const std::string& reg) {
          // 规范化寄存器名
          std::string full_reg = normalizeReg(reg);

          auto it = regs_.find(full_reg);
          if (it != regs_.end()) {
              return it->second;
          }

          // 未知寄存器，返回符号
          return Expr::makeReg(full_reg);
      }

      // 设置寄存器值
      void setReg(const std::string& reg, ExprPtr val) {
          std::string full_reg = normalizeReg(reg);
          regs_[full_reg] = std::move(val);

          // 处理子寄存器（如 eax 影响 rax）
          propagateSubRegs(full_reg);
      }

      // 读内存
      ExprPtr readMem(ExprPtr addr, int bytes) {
          // 如果地址是常量，可以查符号内存
          if (auto const_addr = addr->getConstValue()) {
              auto it = memory_.find(*const_addr);
              if (it != memory_.end()) {
                  return it->second;
              }
          }

          // 返回内存读取表达式
          return Expr::makeMem(addr, bytes * 8);
      }

      // 写内存
      void writeMem(ExprPtr addr, ExprPtr val) {
          if (auto const_addr = addr->getConstValue()) {
              memory_[*const_addr] = val;
          }
          // 非常量地址的写入暂时忽略（保守分析）
      }

      // 打印状态
      void dump() const {
          printf("=== Registers ===\n");
          for (const auto& [reg, val] : regs_) {
              printf("  %s = %s\n", reg.c_str(), val->toString().c_str());
          }
      }

  private:
      std::string normalizeReg(const std::string& reg) {
          // eax -> rax, ax -> rax, al -> rax
          static const std::unordered_map<std::string, std::string> aliases = {
              {"eax", "rax"}, {"ax", "rax"}, {"al", "rax"},
              {"ebx", "rbx"}, {"bx", "rbx"}, {"bl", "rbx"},
              {"ecx", "rcx"}, {"cx", "rcx"}, {"cl", "rcx"},
              {"edx", "rdx"}, {"dx", "rdx"}, {"dl", "rdx"},
              {"esi", "rsi"}, {"si", "rsi"},
              {"edi", "rdi"}, {"di", "rdi"},
              {"ebp", "rbp"}, {"bp", "rbp"},
              {"esp", "rsp"}, {"sp", "rsp"},
              {"r8d", "r8"}, {"r9d", "r9"}, // ...
          };

          auto it = aliases.find(reg);
          return it != aliases.end() ? it->second : reg;
      }

      void propagateSubRegs(const std::string& reg) {
          // 写 eax 时清零高 32 位
          // 简化处理，暂不实现
      }

      std::unordered_map<std::string, ExprPtr> regs_;
      std::unordered_map<uint64_t, ExprPtr> memory_;
  };

  ---
  指令解释器

  // ==================== symbolic_executor.h ====================
  #pragma once
  #include "symbolic_state.h"
  #include "disassembler.h"
  #include <regex>

  class SymbolicExecutor {
  public:
      using ReadMemoryFn = std::function<std::vector<uint8_t>(uint64_t, size_t)>;

      SymbolicExecutor(ReadMemoryFn read_mem) : read_mem_(std::move(read_mem)) {}

      // 执行单条指令
      void execute(const Instruction& insn, SymbolicState& state) {
          const auto& m = insn.mnemonic;

          if (m == "mov" || m == "movabs") {
              handleMov(insn, state);
          } else if (m == "lea") {
              handleLea(insn, state);
          } else if (m == "add") {
              handleBinary(insn, state, ExprKind::Add);
          } else if (m == "sub") {
              handleBinary(insn, state, ExprKind::Sub);
          } else if (m == "imul" || m == "mul") {
              handleBinary(insn, state, ExprKind::Mul);
          } else if (m == "shl" || m == "sal") {
              handleBinary(insn, state, ExprKind::Shl);
          } else if (m == "shr") {
              handleBinary(insn, state, ExprKind::Shr);
          } else if (m == "and") {
              handleBinary(insn, state, ExprKind::And);
          } else if (m == "or") {
              handleBinary(insn, state, ExprKind::Or);
          } else if (m == "xor") {
              handleXor(insn, state);
          } else if (m == "movsxd" || m == "movsx") {
              handleMovsx(insn, state);
          } else if (m == "movzx") {
              handleMovzx(insn, state);
          } else if (m == "cdqe") {
              // 符号扩展 eax -> rax
              auto eax = state.getReg("rax");
              state.setReg("rax", eax);  // 简化处理
          }
          // 跳过 cmp, test, jcc 等不影响数据流的指令
      }

      // 执行基本块
      void executeBlock(const BasicBlock& block, SymbolicState& state) {
          for (const auto& insn : block.instructions()) {
              execute(insn, state);
          }
      }

      // 追踪某个寄存器/内存位置的值
      ExprPtr traceValue(const std::vector<BasicBlock*>& path,
                         const std::string& target_reg) {
          SymbolicState state;

          for (auto* block : path) {
              executeBlock(*block, state);
          }

          return state.getReg(target_reg);
      }

  private:
      // 解析操作数
      struct Operand {
          bool is_reg = false;
          bool is_mem = false;
          bool is_imm = false;
          std::string reg;
          int64_t imm = 0;

          // 内存操作数: [base + index*scale + disp]
          std::string base_reg;
          std::string index_reg;
          int scale = 1;
          int64_t disp = 0;
      };

      Operand parseOperand(const std::string& op, SymbolicState& state) {
          Operand result;

          // 立即数: 0x1234 或 1234
          std::regex imm_regex(R"(^-?(?:0x)?[0-9a-fA-F]+$)");
          if (std::regex_match(op, imm_regex)) {
              result.is_imm = true;
              result.imm = std::stoll(op, nullptr, 0);
              return result;
          }

          // 内存: [rax + rbx*4 + 0x10] 或 [rip + 0x1000]
          std::regex mem_regex(R"(\[([^\]]+)\])");
          std::smatch match;
          if (std::regex_search(op, match, mem_regex)) {
              result.is_mem = true;
              parseMemoryOperand(match[1].str(), result);
              return result;
          }

          // 寄存器
          result.is_reg = true;
          result.reg = op;
          return result;
      }

      void parseMemoryOperand(const std::string& inner, Operand& op) {
          // 简单解析: base + index*scale + disp
          // 例: rax + rcx*4 + 0x10, rip + 0x1000, rbp - 8

          std::regex pattern(R"((\w+)?\s*(?:\+\s*(\w+)\s*\*\s*(\d+))?\s*(?:([+-])\s*(0x[0-9a-fA-F]+|\d+))?)");
          std::smatch m;

          if (std::regex_match(inner, m, pattern)) {
              if (m[1].matched) op.base_reg = m[1].str();
              if (m[2].matched) op.index_reg = m[2].str();
              if (m[3].matched) op.scale = std::stoi(m[3].str());
              if (m[5].matched) {
                  op.disp = std::stoll(m[5].str(), nullptr, 0);
                  if (m[4].matched && m[4].str() == "-") op.disp = -op.disp;
              }
          }
      }

      ExprPtr operandToExpr(const Operand& op, SymbolicState& state, uint64_t insn_addr = 0) {
          if (op.is_imm) {
              return Expr::makeConst(op.imm);
          }

          if (op.is_reg) {
              return state.getReg(op.reg);
          }

          if (op.is_mem) {
              ExprPtr addr = Expr::makeConst(0);

              // base
              if (!op.base_reg.empty()) {
                  if (op.base_reg == "rip") {
                      // RIP 相对寻址
                      addr = Expr::makeConst(insn_addr + op.disp);
                      return state.readMem(addr, 8);
                  }
                  addr = state.getReg(op.base_reg);
              }

              // + index * scale
              if (!op.index_reg.empty()) {
                  auto index = state.getReg(op.index_reg);
                  auto scaled = Expr::makeBinary(ExprKind::Mul, index,
                                                 Expr::makeConst(op.scale));
                  addr = Expr::makeBinary(ExprKind::Add, addr, scaled);
              }

              // + disp
              if (op.disp != 0) {
                  addr = Expr::makeBinary(ExprKind::Add, addr,
                                          Expr::makeConst(op.disp));
              }

              return state.readMem(addr->simplify(), 8);
          }

          return Expr::makeUnknown();
      }

      // 指令处理器
      void handleMov(const Instruction& insn, SymbolicState& state) {
          auto [dst_str, src_str] = splitOperands(insn.operands);

          auto dst = parseOperand(dst_str, state);
          auto src = parseOperand(src_str, state);
          auto src_val = operandToExpr(src, state, insn.address);

          if (dst.is_reg) {
              state.setReg(dst.reg, src_val);
          } else if (dst.is_mem) {
              auto addr = operandToExpr(dst, state, insn.address);
              state.writeMem(addr, src_val);
          }
      }

      void handleLea(const Instruction& insn, SymbolicState& state) {
          auto [dst_str, src_str] = splitOperands(insn.operands);

          auto dst = parseOperand(dst_str, state);
          auto src = parseOperand(src_str, state);  // [base + index*scale + disp]

          // LEA 计算地址但不读取内存
          ExprPtr addr = Expr::makeConst(0);

          if (!src.base_reg.empty()) {
              if (src.base_reg == "rip") {
                  addr = Expr::makeConst(insn.address + insn.size + src.disp);
              } else {
                  addr = state.getReg(src.base_reg);
                  if (src.disp != 0) {
                      addr = Expr::makeBinary(ExprKind::Add, addr,
                                              Expr::makeConst(src.disp));
                  }
              }
          }

          if (!src.index_reg.empty()) {
              auto index = state.getReg(src.index_reg);
              auto scaled = Expr::makeBinary(ExprKind::Mul, index,
                                             Expr::makeConst(src.scale));
              addr = Expr::makeBinary(ExprKind::Add, addr, scaled);
          }

          state.setReg(dst.reg, addr->simplify());
      }

      void handleBinary(const Instruction& insn, SymbolicState& state, ExprKind op) {
          auto [dst_str, src_str] = splitOperands(insn.operands);

          auto dst = parseOperand(dst_str, state);
          auto src = parseOperand(src_str, state);

          auto dst_val = operandToExpr(dst, state);
          auto src_val = operandToExpr(src, state, insn.address);

          auto result = Expr::makeBinary(op, dst_val, src_val)->simplify();

          if (dst.is_reg) {
              state.setReg(dst.reg, result);
          }
      }

      void handleXor(const Instruction& insn, SymbolicState& state) {
          auto [dst_str, src_str] = splitOperands(insn.operands);

          // xor rax, rax => rax = 0
          if (dst_str == src_str) {
              auto dst = parseOperand(dst_str, state);
              state.setReg(dst.reg, Expr::makeConst(0));
          } else {
              handleBinary(insn, state, ExprKind::Xor);
          }
      }

      void handleMovsx(const Instruction& insn, SymbolicState& state) {
          auto [dst_str, src_str] = splitOperands(insn.operands);

          auto dst = parseOperand(dst_str, state);
          auto src = parseOperand(src_str, state);
          auto src_val = operandToExpr(src, state, insn.address);

          auto result = std::make_shared<Expr>();
          result->kind = ExprKind::SignExt;
          result->operand = src_val;

          state.setReg(dst.reg, result);
      }

      void handleMovzx(const Instruction& insn, SymbolicState& state) {
          auto [dst_str, src_str] = splitOperands(insn.operands);

          auto dst = parseOperand(dst_str, state);
          auto src = parseOperand(src_str, state);
          auto src_val = operandToExpr(src, state, insn.address);

          state.setReg(dst.reg, src_val);  // 简化处理
      }

      std::pair<std::string, std::string> splitOperands(const std::string& ops) {
          auto comma = ops.find(',');
          if (comma == std::string::npos) return {ops, ""};

          std::string dst = ops.substr(0, comma);
          std::string src = ops.substr(comma + 1);

          // 去除空格
          auto trim = [](std::string& s) {
              s.erase(0, s.find_first_not_of(" \t"));
              s.erase(s.find_last_not_of(" \t") + 1);
          };
          trim(dst);
          trim(src);

          return {dst, src};
      }

      ReadMemoryFn read_mem_;
  };

  ---
  使用示例

  // 分析 switch 跳转表
  void analyzeSwitch(const CFG& cfg, uint64_t switch_block_addr) {
      auto* block = cfg.blockAt(switch_block_addr);
      if (!block) return;

      SymbolicExecutor executor(read_mem);
      SymbolicState state;

      // 设置初始符号（switch 变量）
      state.setReg("rdi", Expr::makeReg("switch_var", 32));

      // 执行块
      executor.executeBlock(*block, state);

      state.dump();

      // 获取跳转目标表达式
      auto& last_insn = block->instructions().back();
      if (last_insn.mnemonic == "jmp") {
          auto target_expr = state.getReg("rax");  // 假设 jmp rax
          printf("Jump target: %s\n", target_expr->toString().c_str());
      }
  }

  输出示例

  === Registers ===
    rdi = switch_var
    rcx = 0x404000
    rax = sext([0x404000 + (switch_var * 4)])
    rdx = (0x404000 + sext([0x404000 + (switch_var * 4)]))

  Jump target: (0x404000 + sext([0x404000 + (switch_var * 4)]))

  从表达式可以看出：
  - 跳转表基址：0x404000
  - 索引：switch_var * 4
  - 表项格式：32位有符号偏移

  ---
  扩展方向

  | 功能         | 说明                   |
  |--------------|------------------------|
  | 路径敏感分析 | 沿 CFG 路径传播符号    |
  | 约束求解     | 结合 Z3 判断路径可达性 |
  | 内存别名分析 | 判断两个地址是否相同   |
  | 常量传播     | 读取已知内存位置       |

  需要我展开约束求解来解析跳转表吗？